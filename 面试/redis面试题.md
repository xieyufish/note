# Redis面试题

## 1. Redis中的数据类型？

1. 字符串（String）：`set key value`，string类型是二进制安全的，意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象。是redis里面最基本的数据类型，一个建最大能存储512MB；
2. 哈希（hash）：`hmset name key1 value1 key2 value2`，Redis hash是一个键值对集合，是一个string类型的key和value的映射表，hash特别适合用于存储对象；
3. 列表（list）：redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部或者尾部；`lpush name value`、`rpush name value`、 `lrem name index`、 `llen name`
4. 集合（set）：`sadd name value`，Redis的set是string类型的无序集合；集合是通过哈希表实现的，所以添加、删除、查找的复杂度都是O(1)；
5. 有序集合（zset）：`zadd name score value`，zset和set一样也是string类型元素的集合，且不允许重复的成员；不同的是每个元素都会关联一个double类型的分数，redis正是通过分数来为集合中的成员进行从小到大的排序，zset的成员是唯一的，但分数却可以重复。

## 2. Redis中的内存划分？

1. 数据：作为数据库，数据是最主要的部分；这部分占用的内存会统计在info命令输出的used_memory指标中；Redis使用键值对存储数据，其中的值包括5种类型，这5种类型是redis对外提供的，实际上，在Redis内部，每种类型可能有2种或更多的内部编码实现；此外，Redis在存储对象时，并不是直接将数据扔进内存，而是会对对象进行各种包装：如redisObject、SDS等；
2. 进程本身运行需要的内存：如代码、常量池等等；这部分内存大约几兆，在大多数生产环境中与Redis数据占用相比可以忽略，这部分内存不是由jemalloc分配器分配，因此不会统计在used_memory中；
3. 缓冲内存：如客户端缓冲区、复制积压缓冲区、AOF缓冲区等；
4. 内存碎片：在Redis进行分配、回收物理内存过程中产生，例如，对数据的更改频繁，而数据之间的大小相差很大，可能导致redis释放的空间在物理内存中并没有释放，但redis又无法有效利用，就形成了内存碎片，内存碎片不会统计在used_memory中。

## 3. Redis高可用？

在web服务器中，高可用是指服务器可以正常访问的时间，衡量的标准是在多长时间内可以提供正常服务(99.9%，99.99%，99.999%等等)。在Redis中，高可用除了保证提供正常服务，还需要考虑数据容量扩展、数据安全不会丢失等。主要技术包括：

1. 持久化：主要作用是数据备份，即将数据存储在硬盘，保证数据不会因进程退出而丢失；
2. 复制：复制是高可用redis的基础，哨兵和集群都是在复制基础上实现高可用的。复制主要实现了数据的多机备份，以及对于读操作的负载均衡和简单的故障恢复。缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制；
3. 哨兵：在复制的基础上，哨兵实现了自动化的故障恢复。缺陷：写操作无法负载均衡；存储能力受到单机限制；
4. 集群：通过集群，redis解决了写操作无法负载均衡，以及存储能力受到单机限制的问题，实现了较为完善的高可用方案。

## 4. Redis持久化及方式？

Redis是内存数据库，数据都是存储在内存中，为避免进程退出导致数据的永久丢失，定期将redis中的数据以某种形式（数据或命令）从内存保存到硬盘；当redis下次重启时，利用持久化文件实现数据恢复，除此之外，为了进行灾难备份，可以将持久化文件拷贝到一个远程位置。Redis持久化分为如下两种方式：

**RDB持久化**

将当前数据保存到硬盘。将当前进程中的数据生成快照保存到硬盘(因此也称作快照持久化)，保存的文件后缀是rdb；当redis重启时，可以读取快照文件恢复数据。触发命令：`save`和`bgsave`

- save：会阻塞redis服务器进程，直到rdb文件创建完毕为止，在redis服务器阻塞期间，服务器不能处理任何命令请求；已基本被废弃，线上环境杜绝save的使用；
- bgsave：会创建一个子进程，由子进程来负责创建rdb文件，父进程(redis主进程)则继续处理请求，只有在fork子进程时会阻塞服务器；

触发方式：

- 手动触发：命令行执行save和bgsave命令可以触动rdb文件创建；

- 自动触发：在redis的配置文件配置`save m n`，指定当m秒内发生n次变化时，会触发bgsave；当配置有多个save条件时，满足任意一个时都会引起bgsave；
  **save m n**的实现原理：Redis的save m n，是通过serverCron函数、dirty计数器、和lastsave时间戳来实现的。

  serverCron是Redis服务器的周期性操作函数，默认每隔100ms执行一次；该函数对服务器的状态进行维护，其中一项工作就是检查 save m n 配置的条件是否满足，如果满足就执行bgsave。

  dirty计数器是Redis服务器维持的一个状态，记录了上一次执行bgsave/save命令后，服务器状态进行了多少次修改(包括增删改)；而当save/bgsave执行完成后，会将dirty重新置为0。

  例如，如果Redis执行了set mykey helloworld，则dirty值会+1；如果执行了sadd myset v1 v2 v3，则dirty值会+3；注意dirty记录的是服务器进行了多少次修改，而不是客户端执行了多少修改数据的命令。

  lastsave时间戳也是Redis服务器维持的一个状态，记录的是上一次成功执行save/bgsave的时间。

  save m n的原理如下：每隔100ms，执行serverCron函数；在serverCron函数中，遍历save m n配置的保存条件，只要有一个条件满足，就进行bgsave。对于每一个save m n条件，只有下面两条同时满足时才算满足：

  （1）当前时间-lastsave > m

  （2）dirty >= n
  **其他自动触发机制**：主从复制场景下，如果从节点执行全量复制操作，则主节点会执行bgsave命令，并将rdb文件发送给从节点；执行shutdown命令时，自动执行rdb持久化。

bgsave命令的执行流程：

1. Redis父进程首先判断：当前是否在执行save，或bgsave/bgrewriteaof（后面会详细介绍该命令）的子进程，如果在执行则bgsave命令直接返回。bgsave/bgrewriteaof 的子进程不能同时执行，主要是基于性能方面的考虑：两个并发的子进程同时执行大量的磁盘写操作，可能引起严重的性能问题。

2. 父进程执行fork操作创建子进程，这个过程中父进程是阻塞的，Redis不能执行来自客户端的任何命令

3. 父进程fork后，bgsave命令返回”Background saving started”信息并不再阻塞父进程，并可以响应其他命令

4. 子进程创建RDB文件，根据父进程内存快照生成临时快照文件，完成后对原有文件进行原子替换

5. 子进程发送信号给父进程表示完成，父进程更新统计信息

常用配置选项：

- save m n：bgsave自动触发的条件；如果没有save m n配置，相当于自动的rdb持久化关闭，不过此时仍可以通过其他方式触发；
- stop-writes-on-bgsave-error yes：当bgsave出现错误时，Redis是否停止执行写命令；设置为yes，则当硬盘出现问题时，可以及时发现，避免数据的大量丢失；设置为no，则Redis无视bgsave的错误继续执行写命令，当对Redis服务器的系统(尤其是硬盘)使用了监控时，该选项考虑设置为no；
- rdbcompression yes：是否开启RDB文件压缩，默认采用LZF算法对RDB文件进行压缩。虽然压缩耗时，但是可以大大减小RDB文件的体积，因此压缩默认开启，需要注意的是，RDB文件的压缩并不是针对整个文件进行的，而是对数据库中的字符串进行的，且只有在字符串达到一定长度(20字节)时才会进行；
- rdbchecksum yes：是否开启RDB文件的校验，在写入文件和读取文件时都起作用；关闭checksum在写入文件和启动文件时大约能带来10%的性能提升，但是数据损坏时无法发现；
- dbfilename dump.rdb：RDB文件名；
- dir ./：RDB文件和AOF文件所在目录；

**AOF持久化**

将每次执行的写命令保存到硬盘，由于持久化的实时性更好，是目前主流的持久化方式；当redis重启时再次执行AOF文件中的命令来恢复数据。

开启AOF

Redis服务器默认开启RDB，关闭AOF；要开启AOF，需要在配置文件中配置：appendonly yes

执行流程

因为需要记录redis的每条写命令，因此AOF不需要触发，下面介绍AOF执行流程：

- 命令追加(append)
  将redis的写命令追加到缓冲区aof_buf，而不是直接写入文件，主要是为了避免每次有写命令都直接写入硬盘，导致硬盘IO成为redis负载的瓶颈；

- 文件写入(write)和文件同步(sync)
  redis提供了多种AOF缓存区的同步文件策略，策略涉及到操作系统的write函数和fsync函数，说明如下：
  为了提高文件写入效率，在现代操作系统中，当用户调用write函数将数据写入文件时，操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区被填满或超过了指定时限后，才真正将缓冲区的数据写入到硬盘里。这样的操作虽然提高了效率，但也带来了安全问题：如果计算机停机，内存缓冲区中的数据会丢失；因此系统同时提供了fsync、fdatasync等同步函数，可以强制操作系统立刻将缓冲区中的数据写入到硬盘里，从而确保数据的安全性。
  AOF缓存区的同步文件策略由参数appendfsync控制，各个值的含义如下：

  - always：命令写入aof_buf后立即调用系统fsync操作同步到AOF文件，fsync完成后线程返回。这种情况下，每次有写命令都要同步到AOF文件，硬盘IO成为性能瓶颈，Redis只能支持大约几百TPS写入，严重降低了Redis的性能；即便是使用固态硬盘（SSD），每秒大约也只能处理几万个命令，而且会大大降低SSD的寿命。
  - no：命令写入aof_buf后调用系统write操作，不对AOF文件做fsync同步；同步由操作系统负责，通常同步周期为30秒。这种情况下，文件同步的时间不可控，且缓冲区中堆积的数据会很多，数据安全性无法保证。
  - everysec：命令写入aof_buf后调用系统write操作，write完成后线程返回；fsync同步文件操作由专门的线程每秒调用一次。**everysec是前述两种策略的折中，是性能和数据安全性的平衡，因此是Redis的默认配置，也是我们推荐的配置。**

- 文件重写(rewrite)
  随着时间流逝，Redis服务器执行的写命令越来越多，AOF文件也会越来越大；过大的AOF文件不仅会影响服务器的正常运行，也会导致数据恢复需要的时间过长。

  文件重写是指定期重写AOF文件，减小AOF文件的体积。需要注意的是，**AOF重写是把Redis进程内的数据转化为写命令，同步到新的AOF文件；不会对旧的AOF文件进行任何读取、写入操作!**

  关于文件重写需要注意的另一点是：对于AOF持久化来说，文件重写虽然是强烈推荐的，但并不是必须的；即使没有文件重写，数据也可以被持久化并在Redis启动的时候导入；因此在一些实现中，会关闭自动的文件重写，然后通过定时任务在每天的某一时刻定时执行。

  文件重写之所以能够压缩AOF文件，原因在于：

  - 过期的数据不再写入文件
  - 无效的命令不再写入文件：如有些数据被重复设值(set mykey v1, set mykey v2)、有些数据被删除了(sadd myset v1, del myset)等等
  - 多条命令可以合并为一个：如sadd myset v1, sadd myset v2, sadd myset v3可以合并为sadd myset v1 v2 v3。不过为了防止单条命令过大造成客户端缓冲区溢出，对于list、set、hash、zset类型的key，并不一定只使用一条命令；而是以某个常量为界将命令拆分为多条。这个常量在redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD中定义，不可更改，3.0版本中值是64。

  通过上述内容可以看出，由于重写后AOF执行的命令减少了，文件重写既可以减少文件占用的空间，也可以加快恢复速度。
  **文件重写的触发**

  - 手动触发：直接调用bgwriteaof命令，与bgsave有些类似，都是fork子进程进行具体的工作，且都只在fork时阻塞；
  - 自动触发：根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数，以及aof_current_size和aof_base_size状态确定触发时机；
    auto-aof-rewrite-min-size：执行AOF重写时，文件的最小体积，默认值为64MB。
    auto-aof-rewrite-percentage：执行AOF重写时，当前AOF大小(即aof_current_size)和上一次重写时AOF大小(aof_base_size)的比值；
    只有当auto-aof-rewrite-min-size和auto-aof-rewrite-percentage两个参数同时满足时，才会自动触发AOF重写，即bgrewriteaof操作。

  **文件重写流程**

  1. Redis父进程首先判断当前是否存在正在执行 bgsave/bgrewriteaof的子进程，如果存在则bgrewriteaof命令直接返回，如果存在bgsave命令则等bgsave执行完成后再执行。前面曾介绍过，这个主要是基于性能方面的考虑。
  2. 父进程执行fork操作创建子进程，这个过程中父进程是阻塞的。
  3. 父进程fork后，bgrewriteaof命令返回”Background append only file rewrite started”信息并不再阻塞父进程，并可以响应其他命令。**Redis的所有写命令依然写入AOF缓冲区，并根据appendfsync策略同步到硬盘，保证原有AOF机制的正确。**
  4. 由于fork操作使用写时复制技术，子进程只能共享fork操作时的内存数据。**由于父进程依然在响应命令，因此Redis使用AOF重写缓冲区(aof_rewrite_buf)保存这部分数据，防止新AOF文件生成期间丢失这部分数据。也就是说，bgrewriteaof执行期间，Redis的写命令同时追加到aof_buf和aof_rewirte_buf两个缓冲区。**
  5. 子进程根据内存快照，按照命令合并规则写入到新的AOF文件。
  6. 子进程写完新的AOF文件后，向父进程发信号，父进程更新统计信息，具体可以通过info persistence查看。
  7. 父进程把AOF重写缓冲区的数据写入到新的AOF文件，这样就保证了新AOF文件所保存的数据库状态和服务器当前状态一致。
  8. 使用新的AOF文件替换老文件，完成AOF重写。

  常用配置选项：

  - appendonly no：是否开启AOF
  - appendfilename "appendonly.aof"：AOF文件名
  - dir ./：RDB文件和AOF文件所在目录
  - appendfsync everysec：fsync持久化同步策略
  - no-appendfsync-on-rewrite no：AOF重写期间是否禁止fsync；如果开启该选项，可以减轻文件重写时CPU和硬盘的负载（尤其是硬盘），但是可能会丢失AOF重写期间的数据；需要在负载和安全性之间进行平衡
  - auto-aof-rewrite-percentage 100：文件重写触发条件之一
  - auto-aof-rewrite-min-size 64mb：文件重写触发提交之一
  - aof-load-truncated yes：如果AOF文件结尾损坏，Redis启动时是否仍载入AOF文件

## 5. RDB和AOF的优缺点？

- RDB
  - 优点：RDB文件紧凑，体积小，网络传输快，适合全量复制；恢复速度比AOF快很多；与AOF相比，最重要的有点之一是对性能的影响相对较小；
  - 缺点：RDB文件在于其数据快照的持久化方式决定了必然做不到实时持久化，数据的大量丢失很多时候是无法接受的；此外RDB文件需要满足特定格式，兼容性差；
- AOF
  - 优点：支持秒级持久化、兼容性好
  - 缺点：文件大、恢复速度慢、对性能影响大

无论是RDB还是AOF，持久化的开启都是要付出性能方面代价的：对于RDB持久化，一方面是bgsave在进行fork操作时Redis主进程会阻塞，另一方面，子进程向硬盘写数据也会带来IO压力；对于AOF持久化，向硬盘写数据的频率大大提高(everysec策略下为秒级)，IO压力更大，甚至可能造成AOF追加阻塞问题，此外，AOF文件的重写与RDB的bgsave类似，会有fork时的阻塞和子进程的IO压力问题。相对来说，由于AOF向硬盘中写数据的频率更高，因此对Redis主进程性能的影响会更大。

## 6. 持久化过程中的阻塞问题？

**fork阻塞：cpu阻塞**

fork操作：父进程通过fork操作可以创建子进程；子进程创建后，父子进程共享代码段，不共享进程的数据空间，但是子进程会获得父进程的数据空间的副本。在操作系统fork的实际实现中，基本都采用了写时复制技术，即在父/子进程试图修改数据空间之前，父子进程实际上共享数据空间；但是当父/子进程的任何一个试图修改数据空间时，操作系统会为修改的那一部分(内存的一页)制作一个副本。虽然fork时，子进程不会复制父进程的数据空间，但是会复制内存页表（页表相当于内存的索引、目录）；父进程的数据空间越大，内存页表越大，fork时复制耗时也会越多。

在Redis中，无论是RDB持久化的bgsave，还是AOF重写的bgrewriteaof，都需要fork出子进程来进行操作。如果Redis内存过大，会导致fork操作时复制内存页表耗时过多；而Redis主进程在进行fork时，是完全阻塞的，也就意味着无法响应客户端的请求，会造成请求延迟过大。

对于不同的硬件、不同的操作系统，fork操作的耗时会有所差别，一般来说，如果Redis单机内存达到了10GB，fork时耗时可能会达到百毫秒级别（如果使用Xen虚拟机，这个耗时可能达到秒级别）。因此，一般来说Redis单机内存一般要限制在10GB以内；不过这个数据并不是绝对的，可以通过观察线上环境fork的耗时来进行调整。

观察的方法如下：执行命令info stats，查看latest_fork_usec的值，单位为微秒。为了减轻fork操作带来的阻塞问题，除了控制Redis单机内存的大小以外，还可以适度放宽AOF重写的触发条件、选用物理机或高效支持fork操作的虚拟化技术等，例如使用Vmware或KVM虚拟机，不要使用Xen虚拟机。

**AOF追加阻塞：硬盘的阻塞**

在AOF中，如果AOF缓冲区的文件同步策略为everysec，则：在主线程中，命令写入aof_buf后调用系统write操作，write完成后主线程返回；fsync同步文件操作由专门的文件同步线程每秒调用一次。

这种做法的问题在于，如果硬盘负载过高，那么fsync操作可能会超过1s；如果Redis主线程持续高速向aof_buf写入命令，硬盘的负载可能会越来越大，IO资源消耗更快；如果此时Redis进程异常退出，丢失的数据也会越来越多，可能远超过1s。

为此，Redis的处理策略是这样的：主线程每次进行AOF会对比上次fsync成功的时间；如果距上次不到2s，主线程直接返回；如果超过2s，则主线程阻塞直到fsync同步完成。因此，如果系统硬盘负载过大导致fsync速度太慢，会导致Redis主线程的阻塞；此外，使用everysec配置，AOF最多可能丢失2s的数据，而不是1s。

AOF追加阻塞问题定位的方法：

（1）监控info Persistence中的aof_delayed_fsync：当AOF追加阻塞发生时（即主线程等待fsync而阻塞），该指标累加。

（2）AOF阻塞时的Redis日志：Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.

（3）如果AOF追加阻塞频繁发生，说明系统的硬盘负载太大；可以考虑更换IO速度更快的硬盘，或者通过IO监控分析工具对系统的IO负载进行分析，如iostat（系统级io）、iotop（io版的top）、pidstat等。

## 7. redis有哪些架构模式？各自的特点

- 单击版：简单
  缺陷：1. 内存容量有限；2. 处理能力有限；3. 无法高可用

- 主从复制：redis的复制功能允许用户根据一个redis服务器来创建任意多个该服务器的复制品，互为主从节点，主服务器会一直将发生在自己身上的数据更新同步给从服务器，从而一直保证主从服务器的数据相同；
  特点：1. master/slave角色；2. master/slave数据相同；3. 降低master读压力
  缺陷：无法解决master的写负载均衡；故障无法自动恢复；存储能力受到单机限制

- 哨兵：保证高可用；监控各个节点；自动故障迁移
  缺陷：无法实现写负载均衡；存储能力受到单机限制

- 集群：redis3.0之后版本支持redis-cluster集群，采用无中心结构，每个节点保存数据和整个集群状态，每个节点都和其他所有节点连接；
  特点：

  1. 无中心架构；
  2. 数据按照slot存储分布在多个节点，节点间数据共享，可动态调整数据分布；
  3. 可扩展性，可线性扩展到1000个节点，节点可动态添加或删除；
  4. 高可用性，部分节点不可以时，集群仍可用
  5. 实现故障自动failover，节点之间通过gossip协议交换状态信息，用投票机制完成slave到master的角色提升；

  缺点：

  1. 数据通过主从异步复制，不保证数据的强一致性

## 8. redis常用命令？

1. keys pattern：匹配指定模式的key，\*表示所有；
2. exists key：key是否存在；
3. set key value：设置key对应的值为string类型的value；
4. setnx key value：设置key对应的值为string类型的value，如果key已经存在，返回0，nx是not exist的意思；
5. del key：删除某个key，第一次返回1，删除了，第二次返回0；
6. expire：设置过期时间；
7. ttl：查看剩下多少时间；返回负数则key失效，key不存在了；
8. setex：设置key对应的值为string类型的value，并指定此键值对应的有效期；
9. mset：一次设置多个key的值，成功返回ok表示所有的值都设置了，失败返回0表示没有任何值被设置；
10. getset：设置key的值，并返回key的旧值；
11. mget：一次获取多个key的值

## 9. 什么是缓存穿透？如何避免？

对于系统A，假设一秒5000个请求，结果其中4000个请求是黑客发出的恶意攻击，黑客发出的那4000个攻击，缓存中查不到，每次你去数据库里查，也查不到。比如：数据库id是从1开始的，结果黑客发过来的请求id全部都是负数。这样的话，缓存中不会有，请求每次都视缓存于无物，直接查询数据库。这种恶意攻击场景的缓存穿透就会直接把数据库给打死。

解决方案：

- 每次系统从数据库中只要没查到，就写一个空值到缓存里去，这样的话下次便能走缓存了。

## 10. 什么是缓存雪崩？

对于一个系统，缓存机器意外发生了全盘宕机，缓存挂了，此时所有的请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没用什么特别的方案来处理这个故障，DBA很着急，重启数据库，但是数据库立马又被新的流量给打死了。这就是缓存雪崩。

解决方案：

- 事前：redis高可用，主从+哨兵，redis cluster，避免全盘崩溃；
- 事中：本地encache缓存+hystrix限流&降级，避免MySQL被打死；
- 事后：redis持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。

用户发送一个请求，系统A收到请求后，先查本地ehcache缓存，如果没查到再查redis。如果ehcache和redis都没有，再查数据库，将数据库中的结果，写入ehcache和redis中；

限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？走降级，可以返回一些默认的值，或者友情提示，或者空白的值。

好处：

- 数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过；
- 只要数据库不死，就是说，对用户来说，2/5的请求都是可以被处理的；
- 只要有2/5的请求可以被处理，就意味这你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次就可以刷出来一次。

## 11. 为什么要用缓存？

1. 首先我们的数据基本是通过定时任务每日计算刷新的，也就是说一旦定时任务更新完毕，在一天之内数据不会发生改变；
2. 缓存存放在内存里面，每次查询的时候不需要访问mysql数据库，可以比mysql数据库提供更好的访问性能；
3. 缓存具有更高的并发性。

## 12. 缓存带来的问题？

1. 缓存与数据库双写不一致；
2. 缓存雪崩、缓存穿透
3. 缓存并发竞争



## 13. redis的过期策略有哪些？

过期策略是：定期删除+惰性删除。

定期删除：指redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除；假设redis里放了10w个key，都设置了过期时间，你每隔几百毫秒，就检查10w个key，那redis基本上就死了，cpu负载会很高，消耗在你的检查过期key上了。注意，这里可不是每隔100ms就遍历所有的设置过期时间的key，那样就是一场性能上的灾难。实际上redis是每隔100ms**随机抽取**一些key来检查和删除的。

但是问题是，定期删除可能会导致很多过期key到了时间并没有被删除掉，那咋整？所以就是惰性删除了。也就是说，**在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西**。

但是这依然会有问题，如果定期删除漏掉了很多过期key，然后你也没及时去查，也就没走惰性删除，此时会怎样？如果大量过期key堆积在内存里，导致redis内存块耗尽了，怎么办？这就涉及到**内存淘汰机制**。

## 14. redis的内存淘汰机制？

- noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用；
- allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key(这个是最常用的)；
- allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用；
- volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key(这个一般不太合适)；
- volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key；
- volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。

## 15. 手写一个LRU算法？

## 16.如何保证redis的高并发和高可用？

redis实现高并发主要依靠主从架构，一主多从，一般来说很多项目其实就足够了，单主用来写入数据，单机几万QPS，多从用来查询数据，多个从实例可以提供每秒10w的QPS。

如果在实现高并发的同时，要容纳大量的数据，就需要redis集群，使用redis集群之后，可以提供每秒几十万的读写并发。

如果是主从架构的高可用，那么加上哨兵就可以实现，任何一个实例宕机可以进行主备切换。

## 17. redis主从架构？

单机的redis能够承载的QPS大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读高并发的。因此架构做成主从架构，一主多从，主负责写，并且将数据复制到其它的slave节点，从节点负责读。所有的读请求全部走从节点。这样也可以实现水平扩容，支撑读高并发。

主从复制的核心机制：

- redis采用异步方式复制数据到slave节点，从2.8版本开始，slave node会周期性的确认自己每次复制的数据量；
- 一个master node可以有多个slave，但一个slave在同一时刻只能有一个master；
- slave节点可以连接其他的slave节点；
- slave做复制的时候不会阻塞master的正常工作；
- slave做复制时也不会阻塞自己的查询操作，它会用旧数据来提供服务；但是复制完成的时候需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；
- slave主要用来进行横向扩容，做读写分离，扩容的slave可以提高读的吞吐量。

如果采用了主从架构，建议必须开启master节点的持久化，不建议用slave作为master的数据热备，因为如果关掉master的持久化，可能在master宕机重启的时候数据是空的，然后可能一经过复制，slave的数据也丢了。

master的各种备份方案也需要做，万一本地的所有文件丢失了，从备份中挑选一份rdb去恢复master，这样才能确保启动的时候是有数据的，即使采用了后续讲解的高可用机制，slave可以自动接管master，但也可能sentinel还没检测到master failure，master就自动重启了，还是可能导致上面所有的slave数据清空。

## 18. redis主从复制的核心原理？

主从复制的作用：

1. 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式；
2. 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；
3. 负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务，分担服务器负载；
4. 高可用基石：是哨兵和集群能够实施的基础。

**原理**

1. **连接建立阶段：**在主从节点之间建立连接，为数据同步做好准备，有从节点发起

   - 保存主节点信息：从节点服务器内部维护了masterhost和masterport用于存储主节点的ip和port；需要注意slaveof是异步命令，从节点完成主节点ip和port保存后，向发送slaveof命令的redis-cli客户端直接返回ok，实际的复制操作在这之后才开始进行；

   - 建立socket连接：从节点每秒一次调用复制函数replicationCron()，如果发现有主节点可以连接，便会根据主节点ip和port创建socket连接；连接成功，执行如下步骤：

     - 从节点：为该socked建立一个专门处理复制的文件事件处理器，负责后续的复制工作，如接受rdb文件、接受命令传播等；
     - 主节点：接收从节点的socket连接后，为该socket创建相应的客户端状态，并将从节点看作是连接到主节点的一个客户端，后面的步骤会以从节点向主节点发送命令请求的形式来进行

   - 发送ping命令：从节点成为主节点客户端后，发送ping命令进行首次请求，目的是：检查socket连接是否可用，以及主节点当前是否能够处理请求；可能出现3中结果：

     - 返回pong：说明socket连接正常，且主节点当前可以处理请求，复制过程继续；
     - 超时：一定时间后从节点仍未收到主节点回复，说明socket连接不可用，则从节点断开socket连接，并重连；
     - 返回pong以外的结果：如果主节点返回其他结果，如正在处理超时运行脚本，说明主节点当前无法处理命令，则从节点断开socket连接，并重连

   - 身份验证：如果从节点中设置了masterauth选项，则从节点需要向主节点进行身份验证；没有设置该选项，则不需要验证。从节点进行身份验证是通过向主节点发送auth命令进行的，auth命令的参数即为配置文件中的masterauth的值。

     如果主节点设置密码的状态，与从节点masterauth的状态一致（一致是指都存在，且密码相同，或者都不存在），则身份验证通过，复制过程继续；如果不一致，则从节点断开socket连接，并重连。

   - 发送从节点端口信息：身份验证之后，从节点会向主节点发送其监听的端口号，主节点将该信息保存到该从节点对应的客户端的slave_listening_port字段中；该端口信息除了在主节点中执行info Replication时显示以外，没有其他作用。

2. **数据同步阶段：**主从节点连接建立之后，便可以开始进行数据同步，该阶段可以理解为从节点数据的初始化，具体执行方式是：从节点向主节点发送psync命令，开始同步；

3. **命令传播阶段：**数据同步阶段完成后，主从节点进入命令传播阶段，在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。
   在命令传播阶段，除了发送写命令，主从节点还维持这心跳机制：PING和REPLCONF ACK。由于心跳机制的原理涉及部分复制，因此将在介绍了部分复制的相关内容后单独介绍该心跳机制。

