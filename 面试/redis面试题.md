# Redis面试题

## 1. Redis中的数据类型？

1. 字符串（String）：`set key value`，string类型是二进制安全的，意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象。是redis里面最基本的数据类型，一个建最大能存储512MB；
2. 哈希（hash）：`hmset name key1 value1 key2 value2`，Redis hash是一个键值对集合，是一个string类型的key和value的映射表，hash特别适合用于存储对象；
3. 列表（list）：redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部或者尾部；`lpush name value`、`rpush name value`、 `lrem name index`、 `llen name`
4. 集合（set）：`sadd name value`，Redis的set是string类型的无序集合；集合是通过哈希表实现的，所以添加、删除、查找的复杂度都是O(1)；
5. 有序集合（zset）：`zadd name score value`，zset和set一样也是string类型元素的集合，且不允许重复的成员；不同的是每个元素都会关联一个double类型的分数，redis正是通过分数来为集合中的成员进行从小到大的排序，zset的成员是唯一的，但分数却可以重复。

## 2. Redis中的内存划分？

1. 数据：作为数据库，数据是最主要的部分；这部分占用的内存会统计在info命令输出的used_memory指标中；Redis使用键值对存储数据，其中的值包括5种类型，这5种类型是redis对外提供的，实际上，在Redis内部，每种类型可能有2种或更多的内部编码实现；此外，Redis在存储对象时，并不是直接将数据扔进内存，而是会对对象进行各种包装：如redisObject、SDS等；
2. 进程本身运行需要的内存：如代码、常量池等等；这部分内存大约几兆，在大多数生产环境中与Redis数据占用相比可以忽略，这部分内存不是由jemalloc分配器分配，因此不会统计在used_memory中；
3. 缓冲内存：如客户端缓冲区、复制积压缓冲区、AOF缓冲区等；
4. 内存碎片：在Redis进行分配、回收物理内存过程中产生，例如，对数据的更改频繁，而数据之间的大小相差很大，可能导致redis释放的空间在物理内存中并没有释放，但redis又无法有效利用，就形成了内存碎片，内存碎片不会统计在used_memory中。

## 3. Redis高可用？

在web服务器中，高可用是指服务器可以正常访问的时间，衡量的标准是在多长时间内可以提供正常服务(99.9%，99.99%，99.999%等等)。在Redis中，高可用除了保证提供正常服务，还需要考虑数据容量扩展、数据安全不会丢失等。主要技术包括：

1. 持久化：主要作用是数据备份，即将数据存储在硬盘，保证数据不会因进程退出而丢失；
2. 复制：复制是高可用redis的基础，哨兵和集群都是在复制基础上实现高可用的。复制主要实现了数据的多机备份，以及对于读操作的负载均衡和简单的故障恢复。缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制；
3. 哨兵：在复制的基础上，哨兵实现了自动化的故障恢复。缺陷：写操作无法负载均衡；存储能力受到单机限制；
4. 集群：通过集群，redis解决了写操作无法负载均衡，以及存储能力受到单机限制的问题，实现了较为完善的高可用方案。

## 4. Redis持久化及方式？

Redis是内存数据库，数据都是存储在内存中，为避免进程退出导致数据的永久丢失，定期将redis中的数据以某种形式（数据或命令）从内存保存到硬盘；当redis下次重启时，利用持久化文件实现数据恢复，除此之外，为了进行灾难备份，可以将持久化文件拷贝到一个远程位置。Redis持久化分为如下两种方式：

**RDB持久化**

将当前数据保存到硬盘。将当前进程中的数据生成快照保存到硬盘(因此也称作快照持久化)，保存的文件后缀是rdb；当redis重启时，可以读取快照文件恢复数据。触发命令：`save`和`bgsave`

- save：会阻塞redis服务器进程，直到rdb文件创建完毕为止，在redis服务器阻塞期间，服务器不能处理任何命令请求；已基本被废弃，线上环境杜绝save的使用；
- bgsave：会创建一个子进程，由子进程来负责创建rdb文件，父进程(redis主进程)则继续处理请求，只有在fork子进程时会阻塞服务器；

触发方式：

- 手动触发：命令行执行save和bgsave命令可以触动rdb文件创建；

- 自动触发：在redis的配置文件配置`save m n`，指定当m秒内发生n次变化时，会触发bgsave；当配置有多个save条件时，满足任意一个时都会引起bgsave；
  **save m n**的实现原理：Redis的save m n，是通过serverCron函数、dirty计数器、和lastsave时间戳来实现的。

  serverCron是Redis服务器的周期性操作函数，默认每隔100ms执行一次；该函数对服务器的状态进行维护，其中一项工作就是检查 save m n 配置的条件是否满足，如果满足就执行bgsave。

  dirty计数器是Redis服务器维持的一个状态，记录了上一次执行bgsave/save命令后，服务器状态进行了多少次修改(包括增删改)；而当save/bgsave执行完成后，会将dirty重新置为0。

  例如，如果Redis执行了set mykey helloworld，则dirty值会+1；如果执行了sadd myset v1 v2 v3，则dirty值会+3；注意dirty记录的是服务器进行了多少次修改，而不是客户端执行了多少修改数据的命令。

  lastsave时间戳也是Redis服务器维持的一个状态，记录的是上一次成功执行save/bgsave的时间。

  save m n的原理如下：每隔100ms，执行serverCron函数；在serverCron函数中，遍历save m n配置的保存条件，只要有一个条件满足，就进行bgsave。对于每一个save m n条件，只有下面两条同时满足时才算满足：

  （1）当前时间-lastsave > m

  （2）dirty >= n
  **其他自动触发机制**：主从复制场景下，如果从节点执行全量复制操作，则主节点会执行bgsave命令，并将rdb文件发送给从节点；执行shutdown命令时，自动执行rdb持久化。

bgsave命令的执行流程：

1. Redis父进程首先判断：当前是否在执行save，或bgsave/bgrewriteaof（后面会详细介绍该命令）的子进程，如果在执行则bgsave命令直接返回。bgsave/bgrewriteaof 的子进程不能同时执行，主要是基于性能方面的考虑：两个并发的子进程同时执行大量的磁盘写操作，可能引起严重的性能问题。

2. 父进程执行fork操作创建子进程，这个过程中父进程是阻塞的，Redis不能执行来自客户端的任何命令

3. 父进程fork后，bgsave命令返回”Background saving started”信息并不再阻塞父进程，并可以响应其他命令

4. 子进程创建RDB文件，根据父进程内存快照生成临时快照文件，完成后对原有文件进行原子替换

5. 子进程发送信号给父进程表示完成，父进程更新统计信息

常用配置选项：

- save m n：bgsave自动触发的条件；如果没有save m n配置，相当于自动的rdb持久化关闭，不过此时仍可以通过其他方式触发；
- stop-writes-on-bgsave-error yes：当bgsave出现错误时，Redis是否停止执行写命令；设置为yes，则当硬盘出现问题时，可以及时发现，避免数据的大量丢失；设置为no，则Redis无视bgsave的错误继续执行写命令，当对Redis服务器的系统(尤其是硬盘)使用了监控时，该选项考虑设置为no；
- rdbcompression yes：是否开启RDB文件压缩，默认采用LZF算法对RDB文件进行压缩。虽然压缩耗时，但是可以大大减小RDB文件的体积，因此压缩默认开启，需要注意的是，RDB文件的压缩并不是针对整个文件进行的，而是对数据库中的字符串进行的，且只有在字符串达到一定长度(20字节)时才会进行；
- rdbchecksum yes：是否开启RDB文件的校验，在写入文件和读取文件时都起作用；关闭checksum在写入文件和启动文件时大约能带来10%的性能提升，但是数据损坏时无法发现；
- dbfilename dump.rdb：RDB文件名；
- dir ./：RDB文件和AOF文件所在目录；

**AOF持久化**

将每次执行的写命令保存到硬盘，由于持久化的实时性更好，是目前主流的持久化方式；当redis重启时再次执行AOF文件中的命令来恢复数据。

开启AOF

Redis服务器默认开启RDB，关闭AOF；要开启AOF，需要在配置文件中配置：appendonly yes

执行流程

因为需要记录redis的每条写命令，因此AOF不需要触发，下面介绍AOF执行流程：

- 命令追加(append)
  将redis的写命令追加到缓冲区aof_buf，而不是直接写入文件，主要是为了避免每次有写命令都直接写入硬盘，导致硬盘IO成为redis负载的瓶颈；

- 文件写入(write)和文件同步(sync)
  redis提供了多种AOF缓存区的同步文件策略，策略涉及到操作系统的write函数和fsync函数，说明如下：
  为了提高文件写入效率，在现代操作系统中，当用户调用write函数将数据写入文件时，操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区被填满或超过了指定时限后，才真正将缓冲区的数据写入到硬盘里。这样的操作虽然提高了效率，但也带来了安全问题：如果计算机停机，内存缓冲区中的数据会丢失；因此系统同时提供了fsync、fdatasync等同步函数，可以强制操作系统立刻将缓冲区中的数据写入到硬盘里，从而确保数据的安全性。
  AOF缓存区的同步文件策略由参数appendfsync控制，各个值的含义如下：

  - always：命令写入aof_buf后立即调用系统fsync操作同步到AOF文件，fsync完成后线程返回。这种情况下，每次有写命令都要同步到AOF文件，硬盘IO成为性能瓶颈，Redis只能支持大约几百TPS写入，严重降低了Redis的性能；即便是使用固态硬盘（SSD），每秒大约也只能处理几万个命令，而且会大大降低SSD的寿命。
  - no：命令写入aof_buf后调用系统write操作，不对AOF文件做fsync同步；同步由操作系统负责，通常同步周期为30秒。这种情况下，文件同步的时间不可控，且缓冲区中堆积的数据会很多，数据安全性无法保证。
  - everysec：命令写入aof_buf后调用系统write操作，write完成后线程返回；fsync同步文件操作由专门的线程每秒调用一次。**everysec是前述两种策略的折中，是性能和数据安全性的平衡，因此是Redis的默认配置，也是我们推荐的配置。**

- 文件重写(rewrite)
  随着时间流逝，Redis服务器执行的写命令越来越多，AOF文件也会越来越大；过大的AOF文件不仅会影响服务器的正常运行，也会导致数据恢复需要的时间过长。

  文件重写是指定期重写AOF文件，减小AOF文件的体积。需要注意的是，**AOF重写是把Redis进程内的数据转化为写命令，同步到新的AOF文件；不会对旧的AOF文件进行任何读取、写入操作!**

  关于文件重写需要注意的另一点是：对于AOF持久化来说，文件重写虽然是强烈推荐的，但并不是必须的；即使没有文件重写，数据也可以被持久化并在Redis启动的时候导入；因此在一些实现中，会关闭自动的文件重写，然后通过定时任务在每天的某一时刻定时执行。

  文件重写之所以能够压缩AOF文件，原因在于：

  - 过期的数据不再写入文件
  - 无效的命令不再写入文件：如有些数据被重复设值(set mykey v1, set mykey v2)、有些数据被删除了(sadd myset v1, del myset)等等
  - 多条命令可以合并为一个：如sadd myset v1, sadd myset v2, sadd myset v3可以合并为sadd myset v1 v2 v3。不过为了防止单条命令过大造成客户端缓冲区溢出，对于list、set、hash、zset类型的key，并不一定只使用一条命令；而是以某个常量为界将命令拆分为多条。这个常量在redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD中定义，不可更改，3.0版本中值是64。

  通过上述内容可以看出，由于重写后AOF执行的命令减少了，文件重写既可以减少文件占用的空间，也可以加快恢复速度。
  **文件重写的触发**

  - 手动触发：直接调用bgwriteaof命令，与bgsave有些类似，都是fork子进程进行具体的工作，且都只在fork时阻塞；
  - 自动触发：根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数，以及aof_current_size和aof_base_size状态确定触发时机；
    auto-aof-rewrite-min-size：执行AOF重写时，文件的最小体积，默认值为64MB。
    auto-aof-rewrite-percentage：执行AOF重写时，当前AOF大小(即aof_current_size)和上一次重写时AOF大小(aof_base_size)的比值；
    只有当auto-aof-rewrite-min-size和auto-aof-rewrite-percentage两个参数同时满足时，才会自动触发AOF重写，即bgrewriteaof操作。

  **文件重写流程**

  1. Redis父进程首先判断当前是否存在正在执行 bgsave/bgrewriteaof的子进程，如果存在则bgrewriteaof命令直接返回，如果存在bgsave命令则等bgsave执行完成后再执行。前面曾介绍过，这个主要是基于性能方面的考虑。
  2. 父进程执行fork操作创建子进程，这个过程中父进程是阻塞的。
  3. 父进程fork后，bgrewriteaof命令返回”Background append only file rewrite started”信息并不再阻塞父进程，并可以响应其他命令。**Redis的所有写命令依然写入AOF缓冲区，并根据appendfsync策略同步到硬盘，保证原有AOF机制的正确。**
  4. 由于fork操作使用写时复制技术，子进程只能共享fork操作时的内存数据。**由于父进程依然在响应命令，因此Redis使用AOF重写缓冲区(aof_rewrite_buf)保存这部分数据，防止新AOF文件生成期间丢失这部分数据。也就是说，bgrewriteaof执行期间，Redis的写命令同时追加到aof_buf和aof_rewirte_buf两个缓冲区。**
  5. 子进程根据内存快照，按照命令合并规则写入到新的AOF文件。
  6. 子进程写完新的AOF文件后，向父进程发信号，父进程更新统计信息，具体可以通过info persistence查看。
  7. 父进程把AOF重写缓冲区的数据写入到新的AOF文件，这样就保证了新AOF文件所保存的数据库状态和服务器当前状态一致。
  8. 使用新的AOF文件替换老文件，完成AOF重写。

  常用配置选项：

  - appendonly no：是否开启AOF
  - appendfilename "appendonly.aof"：AOF文件名
  - dir ./：RDB文件和AOF文件所在目录
  - appendfsync everysec：fsync持久化同步策略
  - no-appendfsync-on-rewrite no：AOF重写期间是否禁止fsync；如果开启该选项，可以减轻文件重写时CPU和硬盘的负载（尤其是硬盘），但是可能会丢失AOF重写期间的数据；需要在负载和安全性之间进行平衡
  - auto-aof-rewrite-percentage 100：文件重写触发条件之一
  - auto-aof-rewrite-min-size 64mb：文件重写触发提交之一
  - aof-load-truncated yes：如果AOF文件结尾损坏，Redis启动时是否仍载入AOF文件

## 5. RDB和AOF的优缺点？

- RDB
  - 优点：RDB文件紧凑，体积小，网络传输快，适合全量复制；恢复速度比AOF快很多；与AOF相比，最重要的有点之一是对性能的影响相对较小；
  - 缺点：RDB文件在于其数据快照的持久化方式决定了必然做不到实时持久化，数据的大量丢失很多时候是无法接受的；此外RDB文件需要满足特定格式，兼容性差；
- AOF
  - 优点：支持秒级持久化、兼容性好
  - 缺点：文件大、恢复速度慢、对性能影响大

无论是RDB还是AOF，持久化的开启都是要付出性能方面代价的：对于RDB持久化，一方面是bgsave在进行fork操作时Redis主进程会阻塞，另一方面，子进程向硬盘写数据也会带来IO压力；对于AOF持久化，向硬盘写数据的频率大大提高(everysec策略下为秒级)，IO压力更大，甚至可能造成AOF追加阻塞问题，此外，AOF文件的重写与RDB的bgsave类似，会有fork时的阻塞和子进程的IO压力问题。相对来说，由于AOF向硬盘中写数据的频率更高，因此对Redis主进程性能的影响会更大。

## 6. 持久化过程中的阻塞问题？

**fork阻塞：cpu阻塞**

fork操作：父进程通过fork操作可以创建子进程；子进程创建后，父子进程共享代码段，不共享进程的数据空间，但是子进程会获得父进程的数据空间的副本。在操作系统fork的实际实现中，基本都采用了写时复制技术，即在父/子进程试图修改数据空间之前，父子进程实际上共享数据空间；但是当父/子进程的任何一个试图修改数据空间时，操作系统会为修改的那一部分(内存的一页)制作一个副本。虽然fork时，子进程不会复制父进程的数据空间，但是会复制内存页表（页表相当于内存的索引、目录）；父进程的数据空间越大，内存页表越大，fork时复制耗时也会越多。

在Redis中，无论是RDB持久化的bgsave，还是AOF重写的bgrewriteaof，都需要fork出子进程来进行操作。如果Redis内存过大，会导致fork操作时复制内存页表耗时过多；而Redis主进程在进行fork时，是完全阻塞的，也就意味着无法响应客户端的请求，会造成请求延迟过大。

对于不同的硬件、不同的操作系统，fork操作的耗时会有所差别，一般来说，如果Redis单机内存达到了10GB，fork时耗时可能会达到百毫秒级别（如果使用Xen虚拟机，这个耗时可能达到秒级别）。因此，一般来说Redis单机内存一般要限制在10GB以内；不过这个数据并不是绝对的，可以通过观察线上环境fork的耗时来进行调整。

观察的方法如下：执行命令info stats，查看latest_fork_usec的值，单位为微秒。为了减轻fork操作带来的阻塞问题，除了控制Redis单机内存的大小以外，还可以适度放宽AOF重写的触发条件、选用物理机或高效支持fork操作的虚拟化技术等，例如使用Vmware或KVM虚拟机，不要使用Xen虚拟机。

**AOF追加阻塞：硬盘的阻塞**

在AOF中，如果AOF缓冲区的文件同步策略为everysec，则：在主线程中，命令写入aof_buf后调用系统write操作，write完成后主线程返回；fsync同步文件操作由专门的文件同步线程每秒调用一次。

这种做法的问题在于，如果硬盘负载过高，那么fsync操作可能会超过1s；如果Redis主线程持续高速向aof_buf写入命令，硬盘的负载可能会越来越大，IO资源消耗更快；如果此时Redis进程异常退出，丢失的数据也会越来越多，可能远超过1s。

为此，Redis的处理策略是这样的：主线程每次进行AOF会对比上次fsync成功的时间；如果距上次不到2s，主线程直接返回；如果超过2s，则主线程阻塞直到fsync同步完成。因此，如果系统硬盘负载过大导致fsync速度太慢，会导致Redis主线程的阻塞；此外，使用everysec配置，AOF最多可能丢失2s的数据，而不是1s。

AOF追加阻塞问题定位的方法：

（1）监控info Persistence中的aof_delayed_fsync：当AOF追加阻塞发生时（即主线程等待fsync而阻塞），该指标累加。

（2）AOF阻塞时的Redis日志：Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.

（3）如果AOF追加阻塞频繁发生，说明系统的硬盘负载太大；可以考虑更换IO速度更快的硬盘，或者通过IO监控分析工具对系统的IO负载进行分析，如iostat（系统级io）、iotop（io版的top）、pidstat等。

## 7. redis的过期策略有哪些？

过期策略是：定期删除+惰性删除。

定期删除：指redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除；假设redis里放了10w个key，都设置了过期时间，你每隔几百毫秒，就检查10w个key，那redis基本上就死了，cpu负载会很高，消耗在你的检查过期key上了。注意，这里可不是每隔100ms就遍历所有的设置过期时间的key，那样就是一场性能上的灾难。实际上redis是每隔100ms**随机抽取**一些key来检查和删除的。

但是问题是，定期删除可能会导致很多过期key到了时间并没有被删除掉，那咋整？所以就是惰性删除了。也就是说，**在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西**。

但是这依然会有问题，如果定期删除漏掉了很多过期key，然后你也没及时去查，也就没走惰性删除，此时会怎样？如果大量过期key堆积在内存里，导致redis内存块耗尽了，怎么办？这就涉及到**内存淘汰机制**。

## 8. redis的内存淘汰机制？

- noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用；
- allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key(这个是最常用的)；
- allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用；
- volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key(这个一般不太合适)；
- volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key；
- volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。

## 9. 手写一个LRU算法？



